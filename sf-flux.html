<template>
  <style>
    :host {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      height: 100%;
      max-width: 100%;
      width: 320px;
      z-index: 1000;
      transform: translate3d(100%, 0, 0);
      transition: all 0.5s ease;
    }
    :host(.show) {
      transform: translate3d(0, 0, 0);
    }
    * {
      box-sizing: border-box;
    }
    #showHide {
      position: fixed;
      left: -30px;
      top: 0;
      bottom: 0;
      width: 30px;
      height: 30px;
      margin-top: 5px;
      background-color: blue;
      z-index: 2;
    }
    .content {
      z-index: 1;
      background-color: rgba(0, 0, 0, .8);
    }
    .state {
      white-space: pre-wrap;
      max-height: 90px;
      overflow: hidden;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 5px;
      margin-bottom: 5px;
      position: relative;
    }
    .state:hover::after {
      content: '\\\/';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      text-align: center;
      color: white;
    }
    .state.open {
      white-space: pre-wrap;
      max-height: none;
    }
    .state.open:hover::after {
      content: '\/\\';
    }
    .key {
      color: red;
    }
    .string {
      color: green;
    }
    .number, .null, .boolean {
      color: blue;
    }
    input {
      margin: 3px;
      width: calc(100% - 6px);
      padding: 3px;
    }
    .btn3 {
      margin: 3px;
      width: calc(33% - 8px);
      padding: 3px;
    }
  </style>
  <div id="showHide" onclick="showHide()">

  </div>
  <div class="content">
    <simple-tabs options='{"tabHeight": "calc(100vh - 150px)"}'>
      ${targets.join('')}
      <!--- divide -->
      ${states}
    </simple-tabs>
    <input id="addTargetInput" type="text" name="addTargetInput" value="" placeholder="Enter query string of target" onkeyup="addTargetOnEnter(event)">
    <button class="btn3" type="button" name="addTargetButton" onclick="addTarget()">Add Taget</button>
    <button class="btn3" type="button" name="commitAll" onclick="SFLUX.commitAll()">Commit All</button>
    <button class="btn3" type="button" name="resetAll" onclick="SFLUX.resetAllToFirstState()">Reset All</button>
    <button class="btn3 btn2" type="button" name="saveData" onclick="SFLUX.saveData()">Save Data</button>
    <button class="btn3 btn2" type="button" name="loadData" onclick="SFLUX.loadData()">Load Data</button>
  </div>
</template>
<script>
  let sflux = SFComponent['sf-flux'];
  var SFLUX;
  sflux.connectedCallback = function(el) {
    SFLUX = new SFlux([], el);
    SFComponent.stateChanged = function(target, oldState, newState) {
      SFLUX.addState(target, newState, oldState);
    }
  }
  SFComponent.clickEvents['.state'] = function(el) {
    el.classList.contains('open') ? el.classList.remove('open') : el.classList.add('open');
  }

  function addTargetOnEnter(event) {
    if (event.key === 'Enter') {
      addTarget();
    }
  }

  function addTarget() {
    if (SFLUX.addTarget(SFLUX.el.shadowRoot.querySelector('#addTargetInput').value)) {
      SFLUX.el.shadowRoot.querySelector('#addTargetInput').value = "";
    }
  }

  function showHide() {
    let el = SFLUX.el;
    el.classList.contains('show') ? el.classList.remove('show') : el.classList.add('show');
  }
  class SFlux {
    constructor(queries = [], el) {
      this.el = el;
      this.queries = [];
      this.targets = [];
      this.activeStates = [];
      this.states = [];
      let me = this;
      queries.map(q => document.querySelector(q)).forEach(t => me.addTarget(t));
      this.updateState();
    }
    addState(target, state) {
      let index;
      if (Number.isInteger(target)) {
        index = target;
        target = this.targets[index]
      } else {
        index = this.targets.indexOf(target);
      }
      if (index > -1) {
        let active = this.activeStates[index];
        this.states[index].splice(active + 1, 0, JSON.parse(JSON.stringify(state)));
        this.activeStates[index] = active + 1;
        this.updateState();
      }
    }
    addTarget(query) {
      let target = document.querySelector(query);
      if (!target || !target.state) {
        console.log("Not valid Element.");
        return false;
      }
      let index = this.targets.indexOf(target);
      if (index > -1) return;
      this.targets.push(target);
      this.queries.push(query);
      index = this.targets.indexOf(target);
      this.states[index] = [JSON.parse(JSON.stringify(target.state))];
      this.activeStates[index] = 0;
      this.updateState();
      return this.targets;
    }
    removeTarget(target) {
      let index;
      if (Number.isInteger(target)) {
        index = target;
        target = this.targets[index]
      } else {
        index = this.targets.indexOf(target);
      }
      if (index > -1) {
        this.targets.splice(index, 1);
        this.queries.splice(index, 1);
        this.states.splice(index, 1);
        this.activeStates.splice(index, 1);
        this.updateState();
      }
      return this.targets;
    }
    commit(target) {
      let index;
      if (Number.isInteger(target)) {
        index = target;
        target = this.targets[index]
      } else {
        index = this.targets.indexOf(target);
      }
      let last_state = this.states[index][this.states[index].length - 1];
      this.states[index] = [last_state];
      this.activeStates[index] = 0;
      this.updateState();
    }
    commitAll() {
      let me = this;
      this.targets.forEach(t => me.commit(t));
      this.updateState();
    }
    toState(target, n) {
      let index;
      if (Number.isInteger(target)) {
        index = target;
        target = this.targets[index]
      } else {
        index = this.targets.indexOf(target);
      }
      this.activeStates[index] = n;
      target.state = this.states[index][n];
      this.updateState();
    }
    resetToFirstState(target) {
      let index = Number.isInteger(target) ? target : this.targets.indexOf(target);
      this.toState(target, 0);
      this.states[index] = [this.states[index][0]];
      this.updateState();
    }
    resetAllToFirstState() {
      let me = this;
      this.targets.forEach(t => me.resetToFirstState(t));
      this.updateState();
    }
    updateState() {
      let me = this;
      let states = me.states.map((s, i) =>
        `<div data-key="${i}" class="tab" slot="tabs">
        <button class="btn3" type="button" name="commit" onclick="SFLUX.commit(${i})">Commit</button>
        <button class="btn3" type="button" name="reset" onclick="SFLUX.resetToFirstState(${i})">Reset</button>
        <button class="btn3" type="button" name="remove" onclick="SFLUX.removeTarget(${i})">Remove</button>
        ${s.map(j => '<div class="state">' + SFlux.prettyJSON(j) + '</div>').join('')}</div>`
      ).join('');
      this.el.state = {
        targets: me.targets.map((t, i) => `<li slot="list" data-key="${i}">${t.tagName}</li>`),
        states: states
      }
    }
    saveData() {
      this.queries.forEach((q, i) => {
        console.log(q, i);
      });
    }
    static prettyJSON(json) {
      json = JSON.stringify(json, null, 2);
      json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(match) {
        var cls = 'number';
        if (/:$/.test(match)) {
          cls = 'key';
          return '<span class="' + cls + '">' + match + '</span>';
        } else if (/^"/.test(match)) {
          cls = 'string';
        } else if (/true|false/.test(match)) {
          cls = 'boolean';
        } else if (/null/.test(match)) {
          cls = 'null';
        }
        return '<span class="' + cls + '">' + match + '</span>';
      });
    }
    static diff(obj1, obj2) {
      if (typeof obj1 === 'object') {
        let diff = {};
        for (let key in obj1) {
          diff[key] = this.diff(obj1[key], obj2[key]);
        }
        for (let key in obj2) {
          if (!(key in obj1)) diff[key] = this.diff(undefined, obj2[key]);
        }
        return diff;
      } else {
        return {
          type: this.compareValues(obj1, obj2),
          data: {
            oldValue: obj1,
            newValue: obj2
          }
        }
      }
    }
    static compareValues(value1, value2) {
      if (value1 === value2) {
        return 'unchanged';
      }
      if ('undefined' === typeof(value1)) {
        return 'created';
      }
      if ('undefined' === typeof(value2)) {
        return 'deleted';
      }
      return 'updated';
    }
  }
</script>