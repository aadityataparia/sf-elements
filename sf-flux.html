<template>
  <style>
    * {
      white-space: pre-wrap;
    }
    .key {
      color: red;
    }
    .string {
      color: green;
    }
    .number, .null, .boolean {
      color: blue;
    }
  </style>
  <div id="state">
    ${myapp}
  </div>
</template>
<script>
  let sflux = SFComponent['sf-flux'];
  sflux.defaultState = {
    'myapp': {}
  };
  let targets = [];
  var SFLUX;
  sflux.connectedCallback = function(el) {
    SFLUX = new SFlux([], el);
    SFComponent.stateChanged = function(target, oldState, newState) {
      SFLUX.addState(target, newState, oldState);
    }
  }
  class SFlux {
    constructor(targets = [], el) {
      this.el = el;
      this.targets = Array.from(targets);
      this.states = targets.map(t => [t.state]);
      this.activeStates = [0];
    }
    addState(target, state) {
      let index = this.targets.indexOf(target);
      let active = this.activeStates[index];
      if (index > -1) {
        this.states[index].splice(active + 1, 0, state);
        this.activeStates[index] = active + 1;
        this.el.state = {
          'myapp': SFlux.prettyJSON(state)
        }
      }
    }
    addTarget(target) {
      this.targets.push(target);
      let index = this.targets.indexOf(target);
      this.states[index] = [target.state];
      this.activeStates[index] = 0;
      return this.targets;
    }
    removeTarget(target) {
      let index = this.targets.indexOf(target);
      if (index > -1) {
        this.targets.splice(index, 1);
        this.states.splice(index, 1);
        this.activeStates.splice(index, 1);
      }
      return this.targets;
    }
    commit(target) {
      let index = this.targets.indexOf(target);
      let first_state = this.states[index][0];
      let last_state = this.states[index][this.states[index].length - 1];
      this.states[index] = [first_state, last_state];
      this.activeStates[index] = 1;
    }
    commitAll() {
      let me = this;
      this.targets.forEach(t => me.commit(t));
    }
    toState(target, n) {
      let index = this.targets.indexOf(target);
      this.activeStates[index] = n;
      target.state = this.states[index][n];
    }
    resetToFirstState(target) {
      let index = this.targets.indexOf(target);
      this.states[index] = [this.states[index][0]];
      this.activeStates[index] = 0;
    }
    resetAllToFirstState() {
      let me = this;
      this.targets.forEach(t => me.resetToFirstState(t));
    }
    static prettyJSON(json) {
      json = JSON.stringify(json, null, 2);
      json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(match) {
        var cls = 'number';
        if (/:$/.test(match)) {
          cls = 'key';
          return '<span class="' + cls + '">' + match + '</span>';
        } else if (/^"/.test(match)) {
          cls = 'string';
        } else if (/true|false/.test(match)) {
          cls = 'boolean';
        } else if (/null/.test(match)) {
          cls = 'null';
        }
        return '<span class="' + cls + '">' + match + '</span>';
      });
    }
    static diff(obj1, obj2) {
      if (typeof obj1 === 'object') {
        let diff = {};
        for (let key in obj1) {
          diff[key] = this.diff(obj1[key], obj2[key]);
        }
        for (let key in obj2) {
          if (!(key in obj1)) diff[key] = this.diff(undefined, obj2[key]);
        }
        return diff;
      } else {
        return {
          type: this.compareValues(obj1, obj2),
          data: {
            oldValue: obj1,
            newValue: obj2
          }
        }
      }
    }
    static compareValues(value1, value2) {
      if (value1 === value2) {
        return 'unchanged';
      }
      if ('undefined' === typeof(value1)) {
        return 'created';
      }
      if ('undefined' === typeof(value2)) {
        return 'deleted';
      }
      return 'updated';
    }
  }
</script>