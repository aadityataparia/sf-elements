<template state="false">
  <style>
    :host {
      display: none;
      transition: all 0.5s ease;
    }
    :host(.active) {
      display: block;
      opacity: 0;
      animation: slide 0.5s ease forwards;
    }
    @keyframes slide {
      from {
        opacity: 0;
        margin-top: 100px;
      }
      to {
        opacity: 1;
        margin-top: 0;
      }
    }
  </style>
  <slot></slot>
</template>
<script>
  let sfRoute = SFComponent['sf-route'];
  sfRoute.connectedCallback = function(el) {
    el.vdom = SFComponent.toVDOM(el.cloneNode(true));
    refreshRoute(el, window.location.pathname);
  }
  sfRoute.observedAttributes = ['data-route'];
  sfRoute.attributeChangedCallback = function(el, attrName, oldVal, newVal) {
    if (attrName == 'data-route') {
      refreshRoute(el, window.location.pathname);
    }
  }

  let clickEvents = {};
  clickEvents['a'] = function(el, e) {
    if (el.host == window.location.host) {
      e.preventDefault();
      var stateObj = {
        location: el.pathname
      };
      document.title = el.pathname;
      history.pushState(stateObj, "Home", el.pathname);
      refreshAllRoutes();
    }
  }

  window.onpopstate = function(event) {
    refreshAllRoutes();
  };

  function refreshAllRoutes() {
    const path = window.location.pathname;
    let activeRouteEls = [];
    document.querySelectorAll('sf-route').forEach(function(el) {
      if (refreshRoute(el, path)) {
        activeRouteEls.push(el);
      }
    });
    return activeRouteEls;
  }

  function refreshRoute(el, path) {
    let route = el.dataset.route;
    let parsed = parseRoute(route, path);
    const match = parsed.match;
    match ? makeRouteActive(el, parsed.data) : makeRouteInactive(el);
    return match;
  }

  function parseRoute(route, path) {
    let reg = new RegExp('^' + route.replace(/\*\*/, '.{0,}').replace(/\*/g, '[^\/]{0,}').replace(/:[^\/]{0,}/g, '[^\/]{0,}'));
    let pathSplit = SFComponent.getRoutes(path);
    let data = {
      star: []
    };
    for (const [i, r] of SFComponent.getRoutes(route).entries()) {
      if (r[0] == ':') {
        data[r.substr(1)] = pathSplit[i];
      } else if (r == '*') {
        data.star.push(pathSplit[i]);
      }
    }
    return {
      match: path.match(reg),
      data: data
    }
  }

  function makeRouteActive(el, route) {
    let newVdom = SFComponent.evaluateVDOM(el.vdom, {
      route: route
    });
    if (newVdom) {
      SFComponent.replaceNode(el.childNodes, newVdom.children);
      SFComponent.replaceAttributes(el.childNodes, newVdom.children);
    }
    if (el.classList.contains('active')) return;
    try {
      if (el.dataset.lazy && el.dataset.lazy.indexOf('-') > 0) {
        let lazyComps = tryParseJSON(el.dataset.lazy);
        new SFComponent(lazyComps);
        el.dataset.lazy = "";
      }
    } catch (e) {
      console.log(e);
    }
    addClass(el, 'active');
  }

  function makeRouteInactive(el) {
    removeClass(el, 'active');
  }

  function addClass(elem, classN) {
    elem = typeof elem == "string" ? document.querySelector(elem) : elem;
    if (!elem) {
      return false;
    }
    elem.classList.add(classN);
  }

  function removeClass(elem, classN) {
    elem = typeof elem == "string" ? document.querySelector(elem) : elem;
    if (!elem) {
      return false;
    }
    elem.classList.remove(classN);
  }

  //Click event listner
  const MAIN = document.body;

  function clickHandler(e) {
    e = e || window.event;
    let target = e.composedPath()[0] || e.target || e.srcElement;
    for (let k in clickEvents) {
      x = target;
      while (x) {
        if (x.matches(k)) {
          var fn = clickEvents[k];
          if (typeof fn === "function") {
            fn(x, e);
          }
        }
        if (x) {
          x = x.parentElement;
        }
      }
    }
  }

  MAIN.addEventListener('click', clickHandler, false);
</script>